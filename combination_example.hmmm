################################################################################
# Combinations C(n,k) solution
# STUDENT NAME GOES HERE
################################################################################

################################################################################
# register usage
# STUDENTS MUST EXPLAIN ALL REGISTERS THEY USE AND FOR WHAT PURPOSE HERE
################################################################################
# r0 <- 0
# r1 <- n

# HMMMM pre-defined registers
# r13 Function return value
# r14 Function return address
# r15 Stack pointer

# STUIDENTS NEED TO ADD THEIR OWN ASSEMBLY CODE HERE
- R1: n
- R2: k
- R3: n-k
- R4: n!
- R5: k!
- R6: (n-k)!
- R7: intermediate results
- R8: user input
- R9: factorial argument
- R10: return value (from factorial function)
- R14: stack pointer (if needed)
- R15: temp

#### **HMMM Skeleton**

```hmmm
// --- START: Input Section ---
00 read R1          // Read n into R1
01 read R2          // Read k into R2

// --- START: Error Handling Section ---
02 setn R8 0
03 gt R15 R8 R1     // R15 = R1 > 0
04 jmpn R15 25      // If n <= 0, jump to error
05 gt R15 R8 R2     // R15 = R2 > 0
06 jmpn R15 25      // If k <= 0, jump to error
07 sub R3 R1 R2     // R3 = n - k
08 gt R15 R8 R3     // R15 = (n-k) >= 0
09 jmpn R15 25      // If n-k < 0, jump to error

// --- START: Call Factorial for n ---
10 setn R9 0
11 copy R9 R1       // Prepare argument n for factorial(x)
12 jsr 40           // Call factorial, returns in R10
13 copy R4 R10      // Store n! in R4

// --- START: Call Factorial for k ---
14 copy R9 R2       // Prepare argument k for factorial(x)
15 jsr 40           // Call factorial, returns in R10
16 copy R5 R10      // Store k! in R5

// --- START: Call Factorial for n-k ---
17 copy R9 R3       // Prepare argument n-k for factorial(x)
18 jsr 40           // Call factorial, returns in R10
19 copy R6 R10      // Store (n-k)! in R6

// --- START: Final Calculation C(n, k) ---
20 mul R7 R5 R6     // R7 = k! * (n-k)!
21 div R7 R4 R7     // R7 = n! / (k! * (n-k)!)
22 write R7         // Output result
23 halt

// --- START: Error Output Section ---
25 setn R8 0
26 write R8         // Output 0 for error (or your error code)
27 halt

// --- START: Factorial Function ---
40 // Function: factorial(x) at address 40
41 copy R10 R9      // R10 = x (running product/result)
42 setn R8 1        // R8 = 1
43 jeqzn R10 49     // If x == 0, jump to end (0! = 1)
44 setn R15 1       // R15 = 1 (loop counter)
45 // Loop: multiply R10 by decreasing R9
46 mul R8 R8 R15    // R8 = R8 * R15
47 addn R15 1       // R15 = R15 + 1
48 le R11 R15 R9    // R11 = (R15 <= x)
49 jmpn R11 46      // If R15 <= x, repeat loop
50 copy R10 R8      // Move result to R10
51 ret              // Return with result in R10
################################################################################
# read n, print n, and stop
################################################################################
0 read  r1 # read n
1 write r1 # print n
2 halt     # stop the program